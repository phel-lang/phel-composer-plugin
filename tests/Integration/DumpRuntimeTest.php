<?php

declare(strict_types=1);

namespace PhelTest\Composer\Integration;

use Composer\Composer;
use Composer\Config;
use Composer\Package\Locker;
use Composer\Package\Package;
use Composer\Package\RootPackage;
use Composer\Repository\ArrayRepository;
use Phel\Composer\DumpRuntime;
use PHPUnit\Framework\TestCase;

final class DumpRuntimeTest extends TestCase
{
    public function testRunNoDependencies(): void
    {
        $tmpDir = sys_get_temp_dir();
        $runtimeFile = $tmpDir . '/PhelRuntime.php';
        @unlink($runtimeFile);

        $rootPackage = new RootPackage("my-package", "1.0", "1.0");
        $rootPackage->setExtra([
            "phel" => [
                "loader" => [
                    "my-namespace\\" => "src/",
                    "my-other-namespace\\" => ["lib/", "other/"],
                ],
                "loader-dev" => [
                    "my-test-namespace\\" => "tests/",
                ],
            ],
        ]);

        $locker = $this->createMock(Locker::class);
        $locker->method('getLockedRepository')
            ->willReturn(new ArrayRepository([]));

        $config = new Config();
        $config->merge([
            'config' => [
                'vendor-dir' => $tmpDir,
            ],
        ]);

        $composer = new Composer();
        $composer->setPackage($rootPackage);
        $composer->setConfig($config);
        $composer->setLocker($locker);

        $dumpRuntime = new DumpRuntime();
        $dumpRuntime->run($composer);

        $result = file_get_contents($runtimeFile);

        $expected = <<<EOF
<?php

// @generated by Phel
use Phel\Runtime\RuntimeFacade;

require __DIR__ .'/autoload.php';

\$rt = (new RuntimeFacade())->initialize();
\$rt->addPath("my-namespace\\\\", [__DIR__ . '/../src/']);
\$rt->addPath("my-other-namespace\\\\", [__DIR__ . '/../lib/', __DIR__ . '/../other/']);
\$rt->addPath("my-test-namespace\\\\", [__DIR__ . '/../tests/']);
\$rt->loadNs("phel\\\\core");
return \$rt;

EOF;
        self::assertEquals($expected, $result);
    }

    public function testRunWithDependencies(): void
    {
        $tmpDir = sys_get_temp_dir();
        $runtimeFile = $tmpDir . '/PhelRuntime.php';
        @unlink($runtimeFile);

        $rootPackage = new RootPackage("test/my-package", "1.0", "1.0");
        $rootPackage->setExtra([
            "phel" => [
                "loader" => [
                    "my-namespace\\" => "src/",
                    "my-other-namespace\\" => ["lib/", "other/"],
                ],
                "loader-dev" => [
                    "my-test-namespace\\" => "tests/",
                ],
            ],
        ]);

        $dep1Package = new Package("test/dep1", "1.0", "1.0");
        $dep1Package->setExtra([
            "phel" => [
                "loader" => [
                    "dep1\\" => "src/phel/",
                ],
                "loader-dev" => [
                    "dep1\\" => "tests/phel/",
                ],
            ],
        ]);

        $locker = $this->createMock(Locker::class);
        $locker->method('getLockedRepository')
            ->willReturn(new ArrayRepository([$dep1Package]));

        $config = new Config();
        $config->merge([
            'config' => [
                'vendor-dir' => $tmpDir,
            ],
        ]);

        $composer = new Composer();
        $composer->setPackage($rootPackage);
        $composer->setConfig($config);
        $composer->setLocker($locker);

        $dumpRuntime = new DumpRuntime();
        $dumpRuntime->run($composer);

        $result = file_get_contents($runtimeFile);

        $expected = <<<EOF
<?php

// @generated by Phel
use Phel\Runtime\RuntimeFacade;

require __DIR__ .'/autoload.php';

\$rt = (new RuntimeFacade())->initialize();
\$rt->addPath("my-namespace\\\\", [__DIR__ . '/../src/']);
\$rt->addPath("my-other-namespace\\\\", [__DIR__ . '/../lib/', __DIR__ . '/../other/']);
\$rt->addPath("my-test-namespace\\\\", [__DIR__ . '/../tests/']);
\$rt->addPath("dep1\\\\", [__DIR__ . '/test/dep1/src/phel/']);
\$rt->loadNs("phel\\\\core");
return \$rt;

EOF;
        self::assertEquals($expected, $result);
    }
}
